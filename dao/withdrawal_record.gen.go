// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dao

import (
	"context"
	"strings"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"chatgpt-web-new-go/model"
)

func newWithdrawalRecord(db *gorm.DB, opts ...gen.DOOption) withdrawalRecord {
	_withdrawalRecord := withdrawalRecord{}

	_withdrawalRecord.withdrawalRecordDo.UseDB(db, opts...)
	_withdrawalRecord.withdrawalRecordDo.UseModel(&model.WithdrawalRecord{})

	tableName := _withdrawalRecord.withdrawalRecordDo.TableName()
	_withdrawalRecord.ALL = field.NewAsterisk(tableName)
	_withdrawalRecord.ID = field.NewInt64(tableName, "id")
	_withdrawalRecord.UserID = field.NewInt64(tableName, "user_id")
	_withdrawalRecord.Amount = field.NewString(tableName, "amount")
	_withdrawalRecord.Type = field.NewString(tableName, "type")
	_withdrawalRecord.Name = field.NewString(tableName, "name")
	_withdrawalRecord.Contact = field.NewString(tableName, "contact")
	_withdrawalRecord.Account = field.NewString(tableName, "account")
	_withdrawalRecord.Remarks = field.NewString(tableName, "remarks")
	_withdrawalRecord.Message = field.NewString(tableName, "message")
	_withdrawalRecord.Status = field.NewInt32(tableName, "status")
	_withdrawalRecord.IP = field.NewString(tableName, "ip")
	_withdrawalRecord.UserAgent = field.NewString(tableName, "user_agent")
	_withdrawalRecord.CreateTime = field.NewTime(tableName, "create_time")
	_withdrawalRecord.UpdateTime = field.NewTime(tableName, "update_time")
	_withdrawalRecord.IsDelete = field.NewInt32(tableName, "is_delete")

	_withdrawalRecord.fillFieldMap()

	return _withdrawalRecord
}

type withdrawalRecord struct {
	withdrawalRecordDo

	ALL        field.Asterisk
	ID         field.Int64
	UserID     field.Int64  // 申请的用户id
	Amount     field.String // 提现金额 分
	Type       field.String // 提现方式
	Name       field.String // 收款人姓名
	Contact    field.String // 联系方式
	Account    field.String // 收款账号
	Remarks    field.String // 评论
	Message    field.String // 消息
	Status     field.Int32  // 0异常 1正常 3审核中 6等待下发
	IP         field.String
	UserAgent  field.String // ua
	CreateTime field.Time
	UpdateTime field.Time
	IsDelete   field.Int32

	fieldMap map[string]field.Expr
}

func (w withdrawalRecord) Table(newTableName string) *withdrawalRecord {
	w.withdrawalRecordDo.UseTable(newTableName)
	return w.updateTableName(newTableName)
}

func (w withdrawalRecord) As(alias string) *withdrawalRecord {
	w.withdrawalRecordDo.DO = *(w.withdrawalRecordDo.As(alias).(*gen.DO))
	return w.updateTableName(alias)
}

func (w *withdrawalRecord) updateTableName(table string) *withdrawalRecord {
	w.ALL = field.NewAsterisk(table)
	w.ID = field.NewInt64(table, "id")
	w.UserID = field.NewInt64(table, "user_id")
	w.Amount = field.NewString(table, "amount")
	w.Type = field.NewString(table, "type")
	w.Name = field.NewString(table, "name")
	w.Contact = field.NewString(table, "contact")
	w.Account = field.NewString(table, "account")
	w.Remarks = field.NewString(table, "remarks")
	w.Message = field.NewString(table, "message")
	w.Status = field.NewInt32(table, "status")
	w.IP = field.NewString(table, "ip")
	w.UserAgent = field.NewString(table, "user_agent")
	w.CreateTime = field.NewTime(table, "create_time")
	w.UpdateTime = field.NewTime(table, "update_time")
	w.IsDelete = field.NewInt32(table, "is_delete")

	w.fillFieldMap()

	return w
}

func (w *withdrawalRecord) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := w.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (w *withdrawalRecord) fillFieldMap() {
	w.fieldMap = make(map[string]field.Expr, 15)
	w.fieldMap["id"] = w.ID
	w.fieldMap["user_id"] = w.UserID
	w.fieldMap["amount"] = w.Amount
	w.fieldMap["type"] = w.Type
	w.fieldMap["name"] = w.Name
	w.fieldMap["contact"] = w.Contact
	w.fieldMap["account"] = w.Account
	w.fieldMap["remarks"] = w.Remarks
	w.fieldMap["message"] = w.Message
	w.fieldMap["status"] = w.Status
	w.fieldMap["ip"] = w.IP
	w.fieldMap["user_agent"] = w.UserAgent
	w.fieldMap["create_time"] = w.CreateTime
	w.fieldMap["update_time"] = w.UpdateTime
	w.fieldMap["is_delete"] = w.IsDelete
}

func (w withdrawalRecord) clone(db *gorm.DB) withdrawalRecord {
	w.withdrawalRecordDo.ReplaceConnPool(db.Statement.ConnPool)
	return w
}

func (w withdrawalRecord) replaceDB(db *gorm.DB) withdrawalRecord {
	w.withdrawalRecordDo.ReplaceDB(db)
	return w
}

type withdrawalRecordDo struct{ gen.DO }

type IWithdrawalRecordDo interface {
	gen.SubQuery
	Debug() IWithdrawalRecordDo
	WithContext(ctx context.Context) IWithdrawalRecordDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IWithdrawalRecordDo
	WriteDB() IWithdrawalRecordDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IWithdrawalRecordDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IWithdrawalRecordDo
	Not(conds ...gen.Condition) IWithdrawalRecordDo
	Or(conds ...gen.Condition) IWithdrawalRecordDo
	Select(conds ...field.Expr) IWithdrawalRecordDo
	Where(conds ...gen.Condition) IWithdrawalRecordDo
	Order(conds ...field.Expr) IWithdrawalRecordDo
	Distinct(cols ...field.Expr) IWithdrawalRecordDo
	Omit(cols ...field.Expr) IWithdrawalRecordDo
	Join(table schema.Tabler, on ...field.Expr) IWithdrawalRecordDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IWithdrawalRecordDo
	RightJoin(table schema.Tabler, on ...field.Expr) IWithdrawalRecordDo
	Group(cols ...field.Expr) IWithdrawalRecordDo
	Having(conds ...gen.Condition) IWithdrawalRecordDo
	Limit(limit int) IWithdrawalRecordDo
	Offset(offset int) IWithdrawalRecordDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IWithdrawalRecordDo
	Unscoped() IWithdrawalRecordDo
	Create(values ...*model.WithdrawalRecord) error
	CreateInBatches(values []*model.WithdrawalRecord, batchSize int) error
	Save(values ...*model.WithdrawalRecord) error
	First() (*model.WithdrawalRecord, error)
	Take() (*model.WithdrawalRecord, error)
	Last() (*model.WithdrawalRecord, error)
	Find() ([]*model.WithdrawalRecord, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.WithdrawalRecord, err error)
	FindInBatches(result *[]*model.WithdrawalRecord, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.WithdrawalRecord) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IWithdrawalRecordDo
	Assign(attrs ...field.AssignExpr) IWithdrawalRecordDo
	Joins(fields ...field.RelationField) IWithdrawalRecordDo
	Preload(fields ...field.RelationField) IWithdrawalRecordDo
	FirstOrInit() (*model.WithdrawalRecord, error)
	FirstOrCreate() (*model.WithdrawalRecord, error)
	FindByPage(offset int, limit int) (result []*model.WithdrawalRecord, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IWithdrawalRecordDo
	UnderlyingDB() *gorm.DB
	schema.Tabler

	FilterWithNameAndRole(name string, role string) (result []model.WithdrawalRecord, err error)
}

// FilterWithNameAndRole SELECT * FROM @@table WHERE name = @name{{if role !=""}} AND role = @role{{end}}
func (w withdrawalRecordDo) FilterWithNameAndRole(name string, role string) (result []model.WithdrawalRecord, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, name)
	generateSQL.WriteString("SELECT * FROM withdrawal_record WHERE name = ? ")
	if role != "" {
		params = append(params, role)
		generateSQL.WriteString("AND role = ? ")
	}

	var executeSQL *gorm.DB
	executeSQL = w.UnderlyingDB().Raw(generateSQL.String(), params...).Find(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

func (w withdrawalRecordDo) Debug() IWithdrawalRecordDo {
	return w.withDO(w.DO.Debug())
}

func (w withdrawalRecordDo) WithContext(ctx context.Context) IWithdrawalRecordDo {
	return w.withDO(w.DO.WithContext(ctx))
}

func (w withdrawalRecordDo) ReadDB() IWithdrawalRecordDo {
	return w.Clauses(dbresolver.Read)
}

func (w withdrawalRecordDo) WriteDB() IWithdrawalRecordDo {
	return w.Clauses(dbresolver.Write)
}

func (w withdrawalRecordDo) Session(config *gorm.Session) IWithdrawalRecordDo {
	return w.withDO(w.DO.Session(config))
}

func (w withdrawalRecordDo) Clauses(conds ...clause.Expression) IWithdrawalRecordDo {
	return w.withDO(w.DO.Clauses(conds...))
}

func (w withdrawalRecordDo) Returning(value interface{}, columns ...string) IWithdrawalRecordDo {
	return w.withDO(w.DO.Returning(value, columns...))
}

func (w withdrawalRecordDo) Not(conds ...gen.Condition) IWithdrawalRecordDo {
	return w.withDO(w.DO.Not(conds...))
}

func (w withdrawalRecordDo) Or(conds ...gen.Condition) IWithdrawalRecordDo {
	return w.withDO(w.DO.Or(conds...))
}

func (w withdrawalRecordDo) Select(conds ...field.Expr) IWithdrawalRecordDo {
	return w.withDO(w.DO.Select(conds...))
}

func (w withdrawalRecordDo) Where(conds ...gen.Condition) IWithdrawalRecordDo {
	return w.withDO(w.DO.Where(conds...))
}

func (w withdrawalRecordDo) Order(conds ...field.Expr) IWithdrawalRecordDo {
	return w.withDO(w.DO.Order(conds...))
}

func (w withdrawalRecordDo) Distinct(cols ...field.Expr) IWithdrawalRecordDo {
	return w.withDO(w.DO.Distinct(cols...))
}

func (w withdrawalRecordDo) Omit(cols ...field.Expr) IWithdrawalRecordDo {
	return w.withDO(w.DO.Omit(cols...))
}

func (w withdrawalRecordDo) Join(table schema.Tabler, on ...field.Expr) IWithdrawalRecordDo {
	return w.withDO(w.DO.Join(table, on...))
}

func (w withdrawalRecordDo) LeftJoin(table schema.Tabler, on ...field.Expr) IWithdrawalRecordDo {
	return w.withDO(w.DO.LeftJoin(table, on...))
}

func (w withdrawalRecordDo) RightJoin(table schema.Tabler, on ...field.Expr) IWithdrawalRecordDo {
	return w.withDO(w.DO.RightJoin(table, on...))
}

func (w withdrawalRecordDo) Group(cols ...field.Expr) IWithdrawalRecordDo {
	return w.withDO(w.DO.Group(cols...))
}

func (w withdrawalRecordDo) Having(conds ...gen.Condition) IWithdrawalRecordDo {
	return w.withDO(w.DO.Having(conds...))
}

func (w withdrawalRecordDo) Limit(limit int) IWithdrawalRecordDo {
	return w.withDO(w.DO.Limit(limit))
}

func (w withdrawalRecordDo) Offset(offset int) IWithdrawalRecordDo {
	return w.withDO(w.DO.Offset(offset))
}

func (w withdrawalRecordDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IWithdrawalRecordDo {
	return w.withDO(w.DO.Scopes(funcs...))
}

func (w withdrawalRecordDo) Unscoped() IWithdrawalRecordDo {
	return w.withDO(w.DO.Unscoped())
}

func (w withdrawalRecordDo) Create(values ...*model.WithdrawalRecord) error {
	if len(values) == 0 {
		return nil
	}
	return w.DO.Create(values)
}

func (w withdrawalRecordDo) CreateInBatches(values []*model.WithdrawalRecord, batchSize int) error {
	return w.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (w withdrawalRecordDo) Save(values ...*model.WithdrawalRecord) error {
	if len(values) == 0 {
		return nil
	}
	return w.DO.Save(values)
}

func (w withdrawalRecordDo) First() (*model.WithdrawalRecord, error) {
	if result, err := w.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.WithdrawalRecord), nil
	}
}

func (w withdrawalRecordDo) Take() (*model.WithdrawalRecord, error) {
	if result, err := w.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.WithdrawalRecord), nil
	}
}

func (w withdrawalRecordDo) Last() (*model.WithdrawalRecord, error) {
	if result, err := w.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.WithdrawalRecord), nil
	}
}

func (w withdrawalRecordDo) Find() ([]*model.WithdrawalRecord, error) {
	result, err := w.DO.Find()
	return result.([]*model.WithdrawalRecord), err
}

func (w withdrawalRecordDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.WithdrawalRecord, err error) {
	buf := make([]*model.WithdrawalRecord, 0, batchSize)
	err = w.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (w withdrawalRecordDo) FindInBatches(result *[]*model.WithdrawalRecord, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return w.DO.FindInBatches(result, batchSize, fc)
}

func (w withdrawalRecordDo) Attrs(attrs ...field.AssignExpr) IWithdrawalRecordDo {
	return w.withDO(w.DO.Attrs(attrs...))
}

func (w withdrawalRecordDo) Assign(attrs ...field.AssignExpr) IWithdrawalRecordDo {
	return w.withDO(w.DO.Assign(attrs...))
}

func (w withdrawalRecordDo) Joins(fields ...field.RelationField) IWithdrawalRecordDo {
	for _, _f := range fields {
		w = *w.withDO(w.DO.Joins(_f))
	}
	return &w
}

func (w withdrawalRecordDo) Preload(fields ...field.RelationField) IWithdrawalRecordDo {
	for _, _f := range fields {
		w = *w.withDO(w.DO.Preload(_f))
	}
	return &w
}

func (w withdrawalRecordDo) FirstOrInit() (*model.WithdrawalRecord, error) {
	if result, err := w.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.WithdrawalRecord), nil
	}
}

func (w withdrawalRecordDo) FirstOrCreate() (*model.WithdrawalRecord, error) {
	if result, err := w.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.WithdrawalRecord), nil
	}
}

func (w withdrawalRecordDo) FindByPage(offset int, limit int) (result []*model.WithdrawalRecord, count int64, err error) {
	result, err = w.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = w.Offset(-1).Limit(-1).Count()
	return
}

func (w withdrawalRecordDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = w.Count()
	if err != nil {
		return
	}

	err = w.Offset(offset).Limit(limit).Scan(result)
	return
}

func (w withdrawalRecordDo) Scan(result interface{}) (err error) {
	return w.DO.Scan(result)
}

func (w withdrawalRecordDo) Delete(models ...*model.WithdrawalRecord) (result gen.ResultInfo, err error) {
	return w.DO.Delete(models)
}

func (w *withdrawalRecordDo) withDO(do gen.Dao) *withdrawalRecordDo {
	w.DO = *do.(*gen.DO)
	return w
}
